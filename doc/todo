https://graphics.stanford.edu/~seander/bithacks.html
http://www.careercup.com/
http://www.poemofquotes.com/funny-quotes/computer-nerds.php
http://mithileshjoshi.blogspot.co.il/2015/08/every-programmers-see-at-1-time.html

http://puddleofriddles.blogspot.co.il/2011/07/basketball-riddle.html


Here is a first hand story. Some time ago I applied for a job at an algo trading shop. Before they started any interview process I was asked to 
write in real-time online environment programming (C/C++) solution for 3 non-trivial algorithmic problems. 
I was allowed total 160 minutes for this. Naturally I entered Google.com. 
In less than 5 minutes I have discovered solutions for all three. 
By my estimation 160 minutes were barely enough to translate the solution in Java - the one I found - to C and run unitest 
and see if it works. I personally know people who work in the middle management positions. These are smart guys, but they are not there. 
They are not and never was able to find a solution for these kind of problems, neither implement a solution in this kind of time. 


One writing thread, N reading threads. In between a queue of messages. 
How to implement a synchronization message - a message which will be processed only after all reading threads
complet their work.

Travel single linked list in the reverse order. Tip switch direction of the links - O(n) Check that the question is not 
duplicated.


Block diagram for the bakcup system which target backup of the virtual machines - scalable, reliable. 
How many threads should be in the backup? Tip: if the CPU/IO is not a bottleneck and networking 
is the main bottleneck (typical) two thread read/write should be sufficient
to move the data between network interfaces
How to scale the system while keeping the united frontend/management system?
What is the performance of the modern I/O? Tip: consider 128 DDR bus. 
When the CPU will be a bottleneck? Tip: deduplication, real time compression

Different between mutex and a binary semaphore? Tip: mutex is context aware. Only a thread which locks a mutex can free the mutex.
The mutext owner can enter the critical section protected by the mutex multiple times. 

There is a single writer and multiple reader threads. How to implement a mutex protected a data base? 
Tip: in Linux you can use a conditional variable.
Tip2: a global variable discribes a state of the data base - writing, reading. Before a thread enters the critical section it shall check 
and probably modify the state. The test-modify operation shall be atomic.

    

Implemet three functions which manipulate a binary tree:

void insert(node **root, int val)
node *delete(node *root, int val)
void print(node *root)


You have a storage (a hard disk) and two or more servers which can access the storage concurrently. A block write/read is an atomic operation. 
How mutex can be implemented? Tip: https://en.wikipedia.org/wiki/Peterson%27s_algorithm




class Base 
{ 
public : 
virtual void X() 
{ 
cout << "X in parent" << endl; 
} 
}; 

class Child : public Base 
{ 
public : 
virtual void X() 
{ 
cout << "X in child" << endl; 
} 

void Y() 
{ 
cout << " Y in child" << endl; 
} 
}; 


int main() 
{ 
Child c; 
Base b = c; 
b.X();	

Base *ptr = new Child(); 
ptr->X();	// how is this call different from "b.X()" 
return 0; 
} 

Output : 
X in parent 
X in child


Implement a thread pool 

Implement a timer using hash table, hash key is based on the expiration tick



Real programmers do not comment their code. It was hard to write, it should be hard to understand.

Programer needs job, Willing to do Windows.


     

