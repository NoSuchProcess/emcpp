
https://graphics.stanford.edu/~seander/bithacks.html
http://www.careercup.com/
http://www.poemofquotes.com/funny-quotes/computer-nerds.php
http://mithileshjoshi.blogspot.co.il/2015/08/every-programmers-see-at-1-time.html
C++ guidelines https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines

http://puddleofriddles.blogspot.co.il/2011/07/basketball-riddle.html
http://yosefk.com/c++fqa/  Why not C++


Here is a first hand story. Some time ago I applied for a job at an algo trading shop. Before they started any interview process I was asked to 
write in real-time online environment programming (C/C++) solution for 3 non-trivial algorithmic problems. 
I was allowed total 160 minutes for this. Naturally I entered Google.com. 
In less than 5 minutes I have discovered solutions for all three. 
By my estimation 160 minutes were barely enough to translate the solution in Java - the one I found - to C and run unitest 
and see if it works. I personally know people who work in the middle management positions. These are smart guys, but they are not there. 
They are not and never was able to find a solution for these kind of problems, neither implement a solution in this kind of time. 


One writing thread, N reading threads. In between a queue of messages. 
How to implement a synchronization message - a message which will be processed only after all reading threads
complet their work.

Travel single linked list in the reverse order. Tip switch direction of the links - O(n) Check that the question is not 
duplicated.


Block diagram for the bakcup system which target backup of the virtual machines - scalable, reliable. 
How many threads should be in the backup? Tip: if the CPU/IO is not a bottleneck and networking 
is the main bottleneck (typical) two thread read/write should be sufficient
to move the data between network interfaces
How to scale the system while keeping the united frontend/management system?
What is the performance of the modern I/O? Tip: consider 128 DDR bus. 
When the CPU will be a bottleneck? Tip: deduplication, real time compression

Different between mutex and a binary semaphore? Tip: mutex is context aware. Only a thread which locks a mutex can free the mutex.
The mutext owner can enter the critical section protected by the mutex multiple times. 

There is a single writer and multiple reader threads. How to implement a mutex protected a data base? 
Tip: in Linux you can use a conditional variable.
Tip2: a global variable discribes a state of the data base - writing, reading. Before a thread enters the critical section it shall check 
and probably modify the state. The test-modify operation shall be atomic.

    

Implemet three functions which manipulate a binary tree:

void insert(node **root, int val)
node *delete(node *root, int val)
void print(node *root)


You have a storage (a hard disk) and two or more servers which can access the storage concurrently. A block write/read is an atomic operation. 
How mutex can be implemented? Tip: https://en.wikipedia.org/wiki/Peterson%27s_algorithm

// Implement following class
class Bandwidth
{
 	void notify(unsigned);
	unsiged byetsPerSecond();
	const unsigned WINDOW_SIZE = 500; //ms
}

// Assume that exists function
extern unsigned getTimeMs();


The system has two inpiuts and four outputs. Implement a thrad which reads the inputs and write outputs. 
Insure fairness between the outputs. You have following functions
void select(fdW[], fdR[])
bool isReady(fd)
void write(fd, buffer)
void read(fd, buffer)

Tip: maintane a list of output fds where the latest used output moves to the end of the list.



class Base 
{ 
public : 
virtual void X() 
{ 
cout << "X in parent" << endl; 
} 
}; 

class Child : public Base 
{ 
public : 
virtual void X() 
{ 
cout << "X in child" << endl; 
} 

void Y() 
{ 
cout << " Y in child" << endl; 
} 
}; 


int main() 
{ 
Child c; 
Base b = c; 
b.X();	

Base *ptr = new Child(); 
ptr->X();	// how is this call different from "b.X()" 
return 0; 
} 

Output : 
X in parent 
X in child


Implement a thread pool 

Implement a timer using hash table, hash key is based on the expiration tick



Real programmers do not comment their code. It was hard to write, it should be hard to understand.

Programer needs job, Willing to do Windows.


     

Hello

-Assume most recent language standard are available (ES5, SE8, C11, C++11...).
- We expect good performance.
- If missing more requirements details, just make reasonable assumptions of
  your own.
- Solution must be simple and compact.
  No defensive coding, no comments, no unrequested features.
  Only one file 10-20 lines of code
- Work only inside Google Docs: no external editor/IDE/debugger, no copy-paste
  to/from such an editor. We must see the flow of how you write the code.

Implement function check (text) which checks whether brackets within text are
correctly nested. You need to consider brackets of three kinds: (), [], {}.


Examples:
    
check("a(b)") -> true
check("[{}]") -> true
check("[(]") -> false
check("}{") -> false
check("z([{}-()]{a})") -> true
check("") -> true



#!/usr/bin/env python
# -*- coding: utf-8 -*-
def checkP1arentheses(s):
    stack = []
    openningP1arentheses = ['{', '[', '('] 
    closingP1arentheses = ['}', ']', ')'] 
    pairs = {'}':'{', ']':'[', ')':'('}
    for ch in s:
        if ch in openningP1arentheses:
            stack.append(ch)
        elif (ch in closingP1arentheses):
            if (len(stack) == 0):
                return False
            translatedCh = pairs[ch]
            stackTop = stack[-1]
            if (stackTop == translatedCh):
                stack.pop()
            else:
                return False
                
    return (len(stack) == 0)


testLines =  ['1{2}3', '1(2)3', '1[2]3', '1[2(3)4]5', '1{2(3}4)5', "1}2{3", "1{"]
for line in testLines:
    print line, ":", checkP1arentheses(line)



// Implement following class
class Bandwidth
{
        void notify(unsigned);
        unsiged byetsPerSecond();
        const unsigned WINDOW_SIZE = 500; //ms
}

// Assume that exists function
extern unsigned getTimeMs();

Deliver packets from one side to another side of the cloud and feed the packets to the processing server at fixed latency. 


The system has two inpiuts and four outputs. Implement a thrad which reads the inputs and write outputs.
Insure fairness between the outputs. You have following functions
void select(fdW[], fdR[])
bool isReady(fd)
void write(fd, buffer)
void read(fd, buffer)

Tip: maintane a list of output fds where the latest used output moves to the end of the list.


class CGpio
{
public:

	//! Create GPIO
	//!
	//! \arg gpioGroup	- GPIO group (i.e. 'A', 'B', etc)
	//! \arg gpioNum	- GPIO number within the group (0..31)
	CGpio( char gpioGroup,  U8 gpioNum );

	//! Close the GPIO
	virtual ~CGpio();

	//! Set GPIO direction to input
	void setInput( void );

	//! Set GPIO direction to output
	void setOutput( void );

	//! Set GPIO direction to output with initial value
	void setOutput( U8 value);

	//! Write GPIO value
	//!
	//! \arg value - 0 or 1
	void write( U8 value );

	// Read GPIO value
	//!
	//! \return 0 or 1
	U8 read( void );

private:

	// Memory mapped IO
	U8* m_memMapIo;

	// Mask of the pin in registers
	U32 m_pinMask;
};
CGpio::CGpio( char gpioGroup,  U8 gpioNum )
{
	// Map the IO region if was not done so before
	if ( !CMemMap::isMapped( g_memMap ) )
	{
		CMemMap::mapRegion( g_memMap );
	}

	// Get pointer to relevant IO registers
	m_memMapIo = (U8*)g_memMap.m_vmAddress + (PIO_BASE & PIO_MAP_MASK) + (0x200 * (gpioGroup-'A'));

	// Get pin mask
	m_pinMask = BIT(gpioNum);

	// Enable IO
	IO_REG(GPIO_ENABLE) = m_pinMask;

	// Set as input by default
	setInput();
}




Problem
===========
Simplify the implementation below as much as you can. 
Even better if you can also improve performance as part of the simplification!
FYI: This code is over 35 lines and over 300 tokens, but it can be written in
5 lines and in less than 60 tokens.

#include <stdlib.h>
char *func(char *s, char a, char b)
{
    char *aptr;
    char *bptr;
    char *res;
    int i;
    if (s[0] == '\0')
    {
        if ((a == '\0') || (b == '\0'))
            return &(s[0]);
        else
            return NULL;
    }
    i = 0;
    aptr = NULL;
    bptr = NULL;
    while (aptr == NULL && bptr == NULL)
    {
        if (s[i] == a)
            aptr = s+i;
        if (s[i] == b)
            bptr = s+i;
        if (s[i] == '\0')
        {
            if ((aptr != s+i) && (bptr != s+i))
            return NULL;
        }
        i++;
    }

    if (aptr == NULL)
        res = bptr;    
    else if (bptr == NULL)
        res = aptr;        
    else if (aptr < bptr)
        res = aptr;
    else if (bptr < aptr)
        res = bptr;
    else
        res = aptr;

    return res;
}


char *func_v2(char *s, char a, char b)
{
	char *aptr = NULL;
	char *bptr = NULL;
	while (aptr == NULL && bptr == NULL && (*s || !a || !b)  )
	{
		if (*s == a) aptr = s;
		if (*s == b) bptr = s;
		s++;
	}
	if (aptr != NULL) return aptr;
	if (bptr != NULL) return bptr;
	return NULL;
}


Write a function which accepts one of the two integers 5 and 7 and returns the second integer.
The programming language does not have conditions if ... else Suggest at least 3 different solutions

int swap_5_7(int arg)
{
   return (35/arg);
}

int swap_5_7(int arg)
{
   return arg ^ 0x02;
}

int swap_5_7(int arg)
{
   static int const RES[] = {7,0,5}
   return (RES[arg-5]);
}

int swap_5_7(int arg)
{
   return (arg+((x & 2) >> 1)*(-1));
}

int swap_5_7(int arg)
{
   return (5-arg)+7;
}


Calculate Pi with complecity O(N). Tip: divide the circle by N vertical bars. 
Height (square of) of the bar is R^2-x^2. Nuymber of bars is N. 

Frog jumps from stone to stone or can jump over one stone (2 stones distance). 
Write a function which returns number of ways the frog can cross X stones
See http://www.careercup.com/question?id=9707061

Print all 1000 digits numbers 

Difference between float and double

Implement macro offsetof()

How kernel knows thread ID of the calling thread?
Tip - structure thread_info is stored on the stack of the thread.



How the following code can cause an exception:

float get(obj* v, bool* ok) {
  float c;
  if(v->valid) {
    *ok = true;
    c = v->a + v->b;
  }
  else {
   *ok = false; //not ok, so don't expect anything from c
  }
  return c;
}
Tip:Signalling NaN


"They pretend to pay us, and we pretend to work." C++ pretends to provide an object-oriented data model, C++ programmers pretend to respect it, and everyone pretends that the code will work. 


What is "kernel markers" in the Linux kernel?


Purpose of immediate values

An immediate value is used to compile into the kernel variables that sit within
the instruction stream. They are meant to be rarely updated but read often.
Using immediate values for these variables will save cache lines.
This infrastructure is specialized in supporting dynamic patching of the values
in the instruction stream when multiple CPUs are running without disturbing the
+normal system behavior.

Compiling code meant to be rarely enabled at runtime can be done using
if (unlikely(imv_read(var))) as condition surrounding the code. The
smallest data type required for the test (an 8 bits char) is preferred, since
some architectures, such as powerpc, only allow up to 16 bits immediate values.

What is "mcount" and flag --pg in gcc?


What does the following C code

include <stdio.h>

int main()
{
        int a,b,c;
        int l = ({a=0;b=1;c=2;});
        printf("l=%d\r\n", l);
}


what is wrong with the following macro. Moshik wrote "Bugfix: The moron who wrote actual code that runs inside assert statements should be beaten..."
#define AZ(foo)        do { assert((foo) == 0); } while (0)
Mooshik code
#define AZ(foo)        do { if ((foo) != 0) printf("assert"); } while (0)



