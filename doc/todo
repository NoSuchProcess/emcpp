https://graphics.stanford.edu/~seander/bithacks.html
http://www.careercup.com/

http://puddleofriddles.blogspot.co.il/2011/07/basketball-riddle.html



One writing thread, N reading threads. In between a queue of messages. 
How to implement a synchronization message - a message which will be processed only after all reading threads
complet their work.

Travel single linked list in the reverse order. Tip switch direction of the links - O(n) Check that the question is not 
duplicated.


Block diagram for the bakcup system which target backup of the virtual machines - scalable, reliable. 
How many threads should be in the backup? Tip: if the CPU/IO is not a bottleneck and networking 
is the main bottleneck (typical) two thread read/write should be sufficient
to move the data between network interfaces
How to scale the system while keeping the united frontend/management system?
What is the performance of the modern I/O? Tip: consider 128 DDR bus. 
When the CPU will be a bottleneck? Tip: deduplication, real time compression

Different between mutex and a binary semaphore? Tip: mutex is context aware. Only a thread which locks a mutex can free the mutex.
The mutext owner can enter the critical section protected by the mutex multiple times. 

There is a single writer and multiple reader threads. How to implement a mutex protected a data base? 
Tip: in Linux you can use a conditional variable.
Tip2: a global variable discribes a state of the data base - writing, reading. Before a thread enters the critical section it shall check 
and probably modify the state. The test-modify operation shall be atomic.

    

Implemet three functions which manipulate a binary tree:

void insert(node **root, int val)
node *delete(node *root, int val)
void print(node *root)


You have a storage (a hard disk) and two or more servers which can access the storage concurrently. A block write/read is an atomic operation. 
How mutex can be implemented? Tip: https://en.wikipedia.org/wiki/Peterson%27s_algorithm



INFINIDAT:
/**
 * return size if Ok
 */
int itoa(int value, char *s, int size)
{
    int i = 0;
    int chars = size - 1;
    int digits = 0;
    int v = value;
    while (v)
    {
        v = v / 10;
        digits++;
    }
    while (value)
    {
        if (i >= chars)
            break;
       s[digits-1-i] = '0' + value;
        i++;
        value = value / 10;
    }
    if (value == 0)
        return size;
    else
        return 0;


}

inifinidat

What does the following x86 chunk of assembly code
call .next
next:
	pop rasx


There is a region in the RAM of size 1MB. We need a pool of 4 bytes blocks which utilizes as much of the memory as possible. Complexity is O(1).


How to count number of bits in a 64 bits integer?

int main()
{
	// 1.
	char *a = "123";
	// 2.
	char b[] = "123";
        // 3.
        const char *c = "123";
        // 4.
        static char d[] = "123";
	// 5.
	a[0] = '0';
        .................
	// 6.
	return a;
        .................
        // 7.
        return c;
        ................
        // 8. 
        return b;
}







     

